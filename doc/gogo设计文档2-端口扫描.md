## 基础扫描
  红队场景中, 利用的漏洞99%都是tcp协议, udp协议一般用作信息收集, 并且udp协议端口一般都是固定的. 因此, gogo也只专注于TCP协议的端口探测和指纹识别. 只对少数几个UDP服务做了特殊支持,例如nbtcsan.


gogo 使用的是go自带的net/http库实现的tcp全连接扫描, 相比与直接调度系统socket性能会好上很多, 相比于raw socket性能略低一点, 但不会低太多


**为什么不使用SYN扫描?**


SYN快是一个误区, 可能因为masscan很快,masscan默认使用了SYN扫描, 所以下意识认为SYN能提高扫描速度. 实际上SYN扫描并不会提高扫描速度.

假设某个端口关闭, 我向该端口发送握手包的第一阶段SYN包.  可能会drop, 也可能会回复一个RST包告诉我该端口已关闭. 

假设某个端口开放, 同样是发送SYN包, 收到ACK回复, 然后继续建立后续的握手.

我们会发现, SYN扫描与全连接扫描都是先发送一个SYN包, 然后等待返回. 如果端口关闭, 等待的时间都是设置的timeout时间. 


也就是说, SYN扫描与TCP全扫描只有在端口开放的情况下有速率差异, 而实际上大规模的端口扫描过程中, 绝大部分端口都是关闭的.

实际上, 因为大部分端口是关闭的, gogo也只会发送一个syn包, 只有获取相应之后才会建立tcp握手.

而使用rawsocket最大的好处是不占用系统的fd, 可以突破fd限制,  但是就算突破了这个限制, 也还会有来自路由器的限制, 这个在gogo设计文档0中提到.

所以,SYN扫描与TCP全扫描只有微弱的性能差距, 而TCP扫描有更多的优势. 后面会提到. 引入只syn扫描还需要依赖pcap等各种各样的问题.


**为什么不使用tls hello， 而是使用socket发送最简GET请求探测端口协议？**
	成功建立握手后, gogo会发送一个GET的http包, 注意, 这里使用的是刚才建立的tcp信道,而不是使用http库重新发包. 这样可以减少一次三次握手。

回到问题，为什么不使用tls hello？

	首先需要知道，如果http/https收到不符合标准的数据包，例如对https服务发送明文GET请求，会响应400或者tcp链接收到rst包。

	建立tcp握手的时候还不能确定是否是http/https服务。 这时候发送一个tls hello，如果是https服务，则能接收到server hello，继续接下去握手认证直到发送https GET。 如果是http服务可能会回应400协议错误或者RST包。 这样我们还需要发送要给GET请求， 再次通过返回的报文或者状态码判断是否是http服务。

	而如果先使用GET服务，如果是https服务，则会回应400或者rst， 如果是某些tcp服务，例如mysql，则会回应banner，最关键的，如果是http服务，顺便还可以帮助我们获取目标网站的首页。如果收到了rst或400， 再使用系统库中的http api，再次发送一个https的GET请求， 如果还不成功，则判断该端口运行着tcp服务。

这两种方式的理论TTL都是4-5ttl（两次 1.5tcp握手 + 1request/response）。但是显然http服务在内网更加常见， 而且不用考虑tls版本的问题（http也需要在极少数情况下考虑http1.0问题）。 因此，我采用了更简单的http GET请求的方式。


	通过建立tcp握手，然后发送GET请求，再根据返回决定是否发送https的GET请求的方式就是目前gogo对每个端口最基础的探测。

	这个探测，不仅能获取到端口open的信息，如果是http/https服务，还能获取到index页面， title，证书信息，状态码，header中的Server，set-cookie， 甚至进行被动的指纹收集。如果是tcp服务，则有更多的情况，后面会一一解释。

所以使用socket构造的http get 会比tls hello 少上大概0.5 ttl


## 特殊端口
当然，针对一些特殊端口，实际上并不需要刚才提到的那些流程。 例如smb的445端口，ssh的22端口， 几乎不会有其它服务占用这些端口。因此可以针对性的做一些定制化的扫描。
### SMB
smb端口在红队常见中一般会进行信息收集以及ms17010/cve-20190708的探测。


**信息收集**
smb的信息收集略微冷门，似乎是在这两年才被武器化， 可以通过ntlm认证的前面两个阶段获取到，windows详细版本号， dns主机名以及主机名，域名。

使用: `-p smb` or `-p 445`
**MS-17010**
如果存在漏洞， 则可以获取到系统release版本。 这个探测本身并不是内存溢出，所以不会影响对方计算机的使用。还有一个略微冷门的信息，可以获取是否已经被种下doublepulsar后门。

`-p smb -e`
**CVE2019-0708** (暂时停用)
网上大部分工具(例如fscan)的实现都是有问题的，会产生大量误报以及漏报。

`-p smb -e`

### NetBOIS
	主要用来收集域名,shared以及是否是dc的信息, 似乎还可以收集到一些其他信息, 还在研究.

需要注意的是, nbt使用的是udp, 高并发的情况下会产生漏报, 建议启发式扫描结束后,单独对存活ip进行一次nbt扫描,确保准确率.

使用: `-p nbt` or `-p 137`
### WMI
wmi默认收集到的信息与smb默认是一样的, 都是通过ntlm协议获取主机名域名与计算机版本号

`-p wmi`or `-p 135`
### OXID
wmi端口还能获得网卡信息, 寻找内网中的多网卡机器.  使用的是wmi协议, 为了区分wmi, 使用oxid关键字.

使用: `-p oxid`
### SNMP
判断是否是路由器,交换机. 并且snmp中还有一些惊喜, 可能存在内网拓扑信息.不过需要使用单独的工具.

`-p snmp` or `-p 161`


## 指纹识别
### 被动识别
这里提到的被动指纹识别不是真的不发包, 而是相对来说不额外发包. 因为识别http与https需要发送一个http GET包, 这个包用来判断https/http/tcp. 同时还可以用作指纹识别.


实际实现的时候, 发现市面上并没有足够强大的指纹库, 或者指纹库只是某一方面的. 

写这篇文档的时候,有个足够强大的指纹库了:[https://github.com/0x727/FingerprintHub](https://github.com/0x727/FingerprintHub). 可惜历史遗留问题直接兼容这个指纹库可能效果不会更好, 所以保留了原有的指纹库.  而且这个指纹库只限于http的各种指纹,不支持tcp指纹. 

也因为这指纹库中的指纹多但是质量并不一定高, 所以选择了筛选部分高价值指纹的方式合并.

还有一个细节, 在指纹识别的时候, 不只是返回识别是与否的布尔值, 也可以获取一些版本号信息, 例如tomcat ,会在报错页面留下版本号, 指纹识别的同时可以提取该信息. gogo也做了对应的优化与快捷实现的方式.

**http指纹**
支持header, body, 正则, hash四种匹配方式. 并且对正则进行了预编译.

指纹库来自:

- [https://github.com/0x727/FingerprintHub](https://github.com/0x727/FingerprintHub)
- [https://github.com/TideSec/TideFinger](https://github.com/TideSec/TideFinger)
- [https://github.com/shadow1ng/fscan/blob/main/WebScan/info/rules.go](https://github.com/shadow1ng/fscan/blob/main/WebScan/info/rules.go)
- 自行收集的上百个指纹
- ... 



**tcp指纹**
tcp也有一个经验公式, 大多数tcp端口会开放在默认端口且一个tcp端口通常只有一个服务. 因此http协议扫描到以一个指纹后不会停止, 而tcp协议会停止指纹识别.

之前也提到了, 我使用的是tcp的socket发送http GET包, 某些情况下一些tcp端口也会返回一些二进制数据. 甚至某些端口建立连接后会主动返回一些信息.  前者例如mysql, 后者例如redis. 

如果tcp的精准指纹识别失效. 根据另外一个经验公式, 大多数tcp不会修改默认端口来根据port.yaml中配置的端口号反向猜测服务, 通过这种方式猜测出来的指纹将会带上一个星号. 

tcp指纹有一个非常强大的指纹库来自nmap: [https://raw.githubusercontent.com/nmap/nmap/master/nmap-service-probes](https://raw.githubusercontent.com/nmap/nmap/master/nmap-service-probes)

因此大部分tcp指纹从nmap中迁移. 人力有限只实现了少部分指纹. 有重点指纹需求的可以联系我.


### 主动识别
主动指纹这就是另外一个维度了, 需要考虑发送合适的数据包, 并且会带来很大的资源负担. 当然,为了解决这些问题,我也做了各种优化.


**http指纹**
http有一个主动发包的通用特征,就是favicon.ico , 市面上也有一些favicon.ico的hash库, 并且做成hash表, 匹配速度极快(小小的diss一下fscan). favicon.ico hash 主要有md5和mmh3, 目前会同时匹配这两种(为了兼容市面上的指纹库), 目前hash指纹库也是同时维护这两种hash.

剩下的http主动扫描则是常规的目录爆破搭配被动指纹识别. 

其中还有一个点某些url存在或者某些字段代表着存在漏洞, 为此做了一些特殊处理, 可以在指纹库中配置漏洞指纹, 将会在结果中特殊标记, 目前对tomcat和weblogic做了对应的优化.

如果http主动指纹库过大, 耗时可能会特别长, 因此我加入了指纹优先级的概念, 当前默认被动指纹优先级为0, 主动指纹均为1, 预留了大于1的指纹用作大规模目录爆破或者通过js指纹识别, 目前还没有实装.

在todo计划中,还有一个404页面的指纹识别, 如果收集到的404指纹超过一定数量, 将会启用.

小结:

- favicon 指纹
- 目录爆破识别指纹
- 404指纹(todo)



**tcp指纹**
tcp的主动指纹也是另一个维度. 刚才提到了tcp的经验公式, 那么使用这个经验公式,在主动识别阶段也可以进行一些优化.

大部分tcp端口需要主动发包, 根据这个经验, 可以做一些优化, 优先发送默认端口的探测数据包,  如果匹配到了任意一个指纹,就不进行后续发包.

主动发包的tcp指纹库主要也来自nmap. 


### 使用
被动指纹将会自动启用, 不需要添加参数, 而使用主动探测的指纹需要添加`-v`参数

未来的大规模的目录爆破识别指纹的参数是`-vv`, 还未实装.


## 漏洞探测
使用: `-e`

一些漏洞探测使用go的形式实现, 例如ms17-010, shiro. smbghost, snmp的探测. 原因是这些需要多次交互或者动态生成一些参数, 而大部分poc则使用了nuclei.



最初考虑过兼容市面上所有的poc库, 但是最终只选择了nuclei. 有很多原因. 

- 不选择xray是因为xray强依赖dsl, 需要引入一个非常庞大的库
- 不选择goby是因为goby的poc不完全开源,只有第三方提供的才开源, 而且goby的json poc有些混乱
- 其他的一些python的poc库基本都是靠写代码实现的, 说实话, 实现的并不太好.


最好,最优雅的选择就是nuclei. 通过配置yaml就可以实现99%的poc甚至exp攻击. 而且支持tcp的漏洞探测. 最关键的是, 不需要引入任何库.


为了引入nuclei 的poc, 我大概花了一个月的时间移植了nuclei的代码, 并且删除了其中dsl部分. 

而nuclei的pocs很多带有强攻击性, 所以我选择了手动逐个移植而不是全部打包进来.

可以使用`gt -k [ybb] -P nuclei` 查看当前已移植的pocs.


支持nuclei poc还有个隐藏的好处, 我们可以给常见的内网设备做自动化默认口令识别. 这可以极大的提高我们测试速度.

具体的poc开发将会在插件文件中阅读, 不需要写一行代码, 甚至可以直接从burp中复制包就可以完成配置.


自行开发的插件可以使用`gt -k [ybb] -ef file`加载插件文件


而在扫描的时候, 调用全部的poc是一键很蠢的行为(没错,diss的就是fscan), 因此`-e`参数实际上是等于`-E auto`, 也就是设置成自动漏勺模式, 这个模式只会扫描识别到指纹并且漏洞库里有对应指纹的漏洞.  例如,weblogic, 只有探测到weblogic指纹,才会识别iiop与t3, 只有扫到weblogic console,才会进行weblogic弱口令爆破.

当然, 也有这种打全poc的需求, 所以预留了对应的使用方式. `-E all` ,慎用

