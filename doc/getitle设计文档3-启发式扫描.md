

这几年遇到非常多的项目都需要在几天甚至几个小时内完成内网刷分的任务. 而没有之前报告或者内鬼报信的情况下, 内网资产测绘只能使用传统的扫描器一点一点探测, 性能与效率都非常低下. 好在fscan略微改善了条件, 将内网的探测从几个c段提高了整个b段, fscan利用go轻松打到了数千的并发,完成了之前难以实现的并发速度.但是面对一个a段甚至某些大型内网的数十个a段,还是无能为力.


面对这种情况, 我在2020年与几个大哥们商讨出了一个解决方案,并在接近一年的实战中检验了这个方案的可行性.
## 启发式扫描原理
根据经验我们会发现, 入口点的c段以及周边的几个c段通常会存在大量资产. 
​

因此,可以做出猜想: 如果某个c段存在任意一个资产,那么这个c段就可能隐藏着更多资产. 
​

而启发式扫描都是根据这个猜想进行的,对于一些实现细节还有优化,具体的下面会提到.


### B段的启发式扫描
对于B段来说,一共有65535个ip, 256个c段. 

我们需要从所有C段找到存活的C段, 可以采用tcp\udp\icmp协议进行请求. 如果某个C段中存在任意一个回应, 那就将这个C段标记为存活, 之后就不再扫描这个C段了.

这样,如果我们以80端口作为标志, 则只需要扫描65535次. 而对于go来说, 1000个并发是很轻松的事情, 消耗不了多少资源(大概是一核2g服务器 50MB内存,10%CPU), 在老的linux发行版上就算有fd限制也是1024,如果是新发行版,则跑个10000并发也很轻松.

可以计算一下时间, 以2秒为默认超时(实战中测试出来能尽可能的发现目标, 但不影响结果的最短超时时间, icmp为1秒), 1000并发.  65535*2/1000 = 130秒. 非常快, 探测一整个b段的存活C段只需要2分钟. 如果是在linux上,我常用4000的并发,大概只需要30秒.

在喷洒出存活的C段后, 再对存活的C段进行具体的端口探测,可以使用-p参数指定任意的端口号.这样,扫描耗时就变成了 130秒 + 存活的c段数*(256*指定的端口数*2)/1000. 如果存活10个C段, 指定了100个端口, 测绘整个B段的耗时就是 130+10*(256*100*2)/1000 = 642秒, 大概十分钟.
​

当然,这还可以优化, 例如

1. 通过算法以C段优先生成例如 1.1.1.1, 1.1.2.1, 1.1.3.1这样任务顺序, 按照安全圈的命名习惯, 应该叫做C段喷洒(C class Spray)
1. 如果某个C段标记为存活, 这不进行后续发包, 也就是说存活的C段越多耗时越短
1. 输出结果会保留探测存活的ip/24的形式(而不是1.1.1.0/24), 方便二次验证
1. 可配置的探测指标, getitle中有个参数smartprobe, 即-sp 80,icmp,445(默认80)  ,将同时使用三个标志验证,当然耗时也会乘3. (会保留123中提到的优化)
1. 添加-no参数, 只进行C段喷洒, 不进行进一步的存活C段端口扫描
### A段的启发式扫描
A段中一共有256个B段, 65535个C段

这里会发现一个问题,如果指定的是A段, 那这种喷洒方式的耗时就会变成, 65535*256,大概是一千六百多万个ip. 耗时大约是16776960 * 2 /1000= 33553秒=9个小时

会发现,光进行C段喷洒,就需要9个小时.那资产测绘就无从谈起了.
​

还好, 这也是有解决办法的.

刚才提到了以喷洒C段实现的B段启发式扫描, 当然,把这个思路扩大一级, 可以对A段使用.可以将C段作为存活单位, ip作为存活标志位.进行B段喷洒.  对每个C段的第一个ip进行-sp指定的端口探测.

这样, 对A段进行B段喷洒的耗时就可以计算到. 同样是(65535 * 2 /1000)= 130秒

在探测到存活B段的情况下,再单独进行B段的启发扫描, 大概是梯度下降的思路. 对A段进行这种方式的C段喷洒耗时则是 (65535 * 2 /1000) * 存活的B段*130秒. 最坏情况下,才需要9个小时,正常情况,1个小时即可完成对A段的C段存活测绘.
​

同样的, 可以优化:
B段的启发式扫描优化同样适用与这里, 还添加了一些针对性的优化

1. 添加ipprobe参数, -ipp 1,254(默认1), 指定C段中的标志IP. 
1. 添加-no参数, 只进行B段喷洒, 不进行进一步的C段喷洒与端口扫描
1. 在进行B段喷洒的时候,默认端口为icmp. 可以使用-sp指定任意端口或协议
1. 在-p只指定了1或2个端口的时候,不进行C段喷洒, 直接进行端口扫描. ( 因为C段喷洒,约等于进行一次单端口全扫描)



### 综合的启发式扫描模式使用
结合上面说的两个种方式, 就可以得到多种用法.
​

update:

为了使用启发式扫描, 引入了近10个参数, 以及3-5个输出文件, 使用变得复杂, 也有好多人与我反馈了这个问题.

为了解决这个问题, 我给大部分使用场景添加了workflow解决方案, 现在大部分情况只需要一个参数就能解决了.

1. 从B段中发现存活的C段(C段喷洒), `gt -ip 192.168.1.1/16 -m s -no` or `gt -w 192c`
2. 从A段中发现存活的B段(B段喷洒), `gt -ip 10.1.1.1/8 -m ss -no` or `gt -w 10b`
3. 从A段中发现存活的C段(A段的启发式C段喷洒), `gt -ip 10.1.1.1/8 -m sc` or `gt -w 10c`
4. 自定义B段的C段喷洒, `gt -l b.txt -m s -no` or `gt -w c -l b.txt`
5. 自定义A段的B段喷洒, `gt -l a.txt -m ss -no` or `gt -w b -l a.txt`
6. 使用icmp协议发现A段中所有存活的IP,   `gt -ip 10.1.1.1/8 -m ss  -p icmp` or `gt -w 10ip`(单端口的-m ss扫描做了特殊的优化, 具体见:A段启发式扫描优化4 )
7. 使用icmp协议发现A段中所有的数据库, `gt -ip 10.1.1.1/8 -m ss  -p db` or `gt -w 10 -p db` 禁止ping内网需要使用 `gt -w 10noping -p db`
8. 使用80端口探测A段中所有的数据库, `gt -ip 10.1.1.1/8 -m ss  -sp 80 -p db` `gt -w 10 -sp 80 -p db`
9. 自动化探测172,192,10等常见内网网段, `gt -m a -no`(已经弃用) or  `gt -w interc`
10. 启发式扫描B段常见端口资产, `gt -ip 192.168.1.1/16 -m s -p win,top2,db` or `gt -w 192`
11. 启发式扫描C段常见端口资产, `gt -ip 10.1.1.1/8 -m ss -p win,top2,db` or `gt -w 10`



一些特殊情况的使用常见

1. 假设80端口存在ACL的C段喷洒, `gt -ip 10.1.1.1/8 -m s -sp 22,445,icmp -no` or `gt -w 10c -sp 22,445,icmp`
2. 假设网关ip为1,253,254的B段喷洒 ,`gt -ip 10.1.1.1/8 -m ss -ipp 1,253-254 -no ` or `gt -w 10b -ipp 1,253-254`
3. 假设禁ping情况下, 网关ip为1,253,254的B段喷洒, `gt -ip 10.1.1.1/8 -m ss -sp 80,22 -ipp 1,253-254 -no ` or `gt -w 10b -sp 80,22 -ipp 1,253-254`


一些辅助参数

-  -f 扫描结果保存到文件, 默认文件时压缩加密的, 同时不会在命令行输出扫描结果,只会输出扫描进度
- -af 自动生成文件名
- -hf 自动生成做了隐藏的文件名 
- -F 格式化输出文件, 压缩加密的文件变成人类可读的文件, 存在一些子参数
   - -o ip , 从扫描结果过滤自定义的内容输出, 例如 gt -F 1.dat -o ip 
   - -f , 输出到文件, 例如,gt -F 1.dat -o ip -f ip.txt
   - -af , 根据元数据自动生成格式化的文件名, 例如, gt -F 1.dat -af
- -P inter 输出-m a模式下自动探测的内网网段与探测配置

如果是添加了-no参数,就不需要指定-o参数进行过滤了, 直接gt -F 1.dat 即可

- -l 参数不需要先-F解密, 会自动判断是否被加密,并正确读取, 当然也可以直接读正常的文本进行扫描



**缺点**:

1. 这样大规模的扫描,是很难逃过流量设备与蜜罐的检测的, 所以使用这种方法扫描的时候需要考虑失去这个点的后果
1. 为了效率, 可能存在一定程度的漏报, 根据我的经验, 漏报率大概在10%左右







